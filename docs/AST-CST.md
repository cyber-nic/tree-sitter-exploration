### **AST vs. CST: Key Differences**

The terms **Abstract Syntax Tree (AST)** and **Concrete Syntax Tree (CST)** are often mentioned in the context of parsers and programming language tooling. However, they are **not interchangeable**; they have distinct purposes and structures.

#### **Concrete Syntax Tree (CST):**

- **What It Is**:
  - A **complete representation** of the source code, including every detail of the syntax, such as punctuation, comments, and redundant elements.
  - Directly generated by a parser.
- **Characteristics**:
  - Captures all tokens and structural details (e.g., `{`, `;`, `,`).
  - Mirrors the grammar exactly.
  - Typically larger and more detailed than an AST.
- **Use Cases**:
  - Syntax highlighting.
  - Code formatting.
  - Refactoring operations.
  - Parsing the original source into a hierarchical structure.

#### **Abstract Syntax Tree (AST):**

- **What It Is**:
  - A **simplified representation** of the code's structure, focusing on its semantics rather than syntax.
  - Often derived from the CST by filtering out unnecessary syntax details (e.g., parentheses, commas).
- **Characteristics**:
  - Ignores non-essential syntax (e.g., `{` and `}`) but retains semantic elements (e.g., function calls, variable declarations).
  - Easier to work with for higher-level program analysis and transformations.
  - More compact than a CST.
- **Use Cases**:
  - Compiler optimizations.
  - Static analysis.
  - Code generation (e.g., intermediate representation in compilers).

---

### **Does `smacker/go-tree-sitter` or `tree-sitter/go-tree-sitter` Provide a CST or AST?**

Both **`smacker/go-tree-sitter`** and **`tree-sitter/go-tree-sitter`** provide **CSTs**, not ASTs. However, the distinction can become blurry because `smacker/go-tree-sitter` documentation sometimes mentions **AST** in its descriptions. This is likely a **misleading terminology** rather than a functional difference.

#### **Why They Provide CSTs**:

1. **Tree-sitter's Design**:

   - Tree-sitter itself is a **parser generator** that produces CSTs by design. Its primary purpose is to parse the source code exactly according to the grammar and generate a detailed, complete tree structure (CST).
   - It retains details like punctuation, keywords, and even comments.

2. **No AST Transformation**:

   - Neither library performs the transformation from CST to AST automatically. You’d need to implement this yourself if needed.

3. **Why `smacker/go-tree-sitter` Mentions AST**:
   - The term **AST** might be used loosely to describe the CST since many developers equate "syntax tree" with AST, even when it’s technically a CST.
   - This is a documentation inconsistency, not a difference in functionality.

---

### **How to Use Each Library for AST-Like Behavior**

If you need an **AST** instead of a **CST**, you can **filter or transform the CST** to remove non-essential syntax details. Here’s how:

#### **1. Traverse and Filter the CST**

Manually traverse the CST and remove nodes that don’t contribute to the program's semantics (e.g., punctuation, redundant nodes):

```go
func convertToAST(node *sitter.Node, code []byte) *ASTNode {
	if node == nil {
		return nil
	}

	// Skip non-semantic nodes (e.g., punctuation)
	if isNonSemanticNode(node) {
		return nil
	}

	// Create a simplified AST node
	astNode := &ASTNode{
		Type: node.Type(),
		Name: node.Content(code), // Extract content (e.g., identifiers)
	}

	// Recursively process children
	for i := 0; i < int(node.ChildCount()); i++ {
		child := convertToAST(node.Child(i), code)
		if child != nil {
			astNode.Children = append(astNode.Children, child)
		}
	}

	return astNode
}

func isNonSemanticNode(node *sitter.Node) bool {
	// Example: Skip punctuation or whitespace nodes
	nonSemanticTypes := map[string]struct{}{
		"punctuation": {},
		"comment":     {},
	}
	_, isNonSemantic := nonSemanticTypes[node.Type()]
	return isNonSemantic
}
```

---

#### **2. Use Tree-Sitter Queries**

Tree-sitter supports **querying specific nodes** using its query language. This allows you to extract relevant nodes directly, effectively working with the CST as if it were an AST.

Example:

```go
query := `
  (function_declaration name: (identifier) @func_name)
  (variable_declaration name: (identifier) @var_name)
`
q, err := sitter.NewQuery([]byte(query), language)
if err != nil {
	panic(err)
}

queryCursor := sitter.NewQueryCursor()
queryCursor.Exec(q, rootNode)

for {
	match, found := queryCursor.NextMatch()
	if !found {
		break
	}

	for _, capture := range match.Captures {
		fmt.Printf("Captured: %s\n", capture.Node.Content(code))
	}
}
```

---

### **Summary of Key Points**

- **Tree-sitter Provides CSTs**:

  - Both `smacker/go-tree-sitter` and `tree-sitter/go-tree-sitter` expose the **CST** generated by Tree-sitter.
  - If the `smacker/go-tree-sitter` documentation mentions AST, it's a loose use of terminology.

- **AST vs. CST in Practice**:

  - CST includes all syntax details (e.g., punctuation, comments).
  - AST is a simplified representation that focuses on semantics and ignores extraneous syntax.

- **How to Get an AST**:
  - You can transform the CST into an AST by filtering out non-semantic nodes or by using Tree-sitter’s query capabilities to extract relevant nodes.
